<!-- Chapter 1: The Road Ahead -->
<h1>Chapter 1</h1>
<hr />
<h2>The Road Ahead</h2>

<div class="blackbox">
<div class="blackbox-title">
<strong>Learning Objectives</strong>
</div>
<div class="blackbox-contents">
<ul>
 	<li>Understand the concept of an algorithm.</li>
 	<li>Understand how computers work and execute programs.</li>
 	<li>Become familiar with what you can do with computer science.</li>
</ul>
</div>
</div>



<h3>1.1 What is Computer Science?</h3>
<hr />

<p>This book is an introduction to the field of computer science, so we will
begin by talking about what computer science is.  Unlike other areas, like
biology or history, this may not be that obvious.  People often are confused
about what computer science actually is all about.  In particular, it is
<strong>not</strong> any of the following things:</p>

<ul>
<li>The study of how to build computer hardware (this is "computer
engineering").</li>

<li>The practice of setting up computer systems and installing things on them
(this is "information technology").</li>

<li>The use of computer applications such as email clients, word processors and
spreadsheet applications (this is "computer literacy").</li>
</ul>


<p>Instead, computer science is all about algorithms.  An <strong>algorithm</strong> is a detailed, step-by-step procedure for
solving a particular problem.  Algorithms are essentially instructions that
tell us how to solve a problem from beginning to end.  They are similar to
recipes.  When you follow a recipe, you also perform the instructions given one
by one.  The difference is that the result of your work when following a recipe
is a food of some kind (hopefully cake).  The result of your work following an
algorithm is a solution to a problem.</p>

<p>The study of algorithms actually predates the existence of computers by
thousands of years<a class="anchor" id="back1">&nbsp;</a><a href="#note1" aria-describedby="footnote-label"></a>.
One of the first known algorithms was described by the Greek mathematician
Euclid in his book <em>Elements</em> around 300 BCE.  The algorithm was to find
the greatest common divisor between two numbers.  For example, the greatest
common divisor of 12 and 30 is 6 because 6 is the biggest number that goes into
both 12 and 30 evenly.</p>

<figure>
<img src="images/euclid.jpg" alt="Euclid writing his book &quot;Elements&quot;"/>
<figcaption>Euclid</figcaption>
</figure>

<p>Other mathematicians devised algorithms for solving other problems, such as
adding, multiplying, factorizing, finding roots of equations, etc.  The word
"algorithm" itself comes from the name of Muḥammad ibn Mūsā al-Khwārizmī, a
Persian mathematician who wrote on algorithms for solving algebra and arithmetic
problems.  The word "algebra" also comes from the title of one of
al-Khwārizmī's books.</p>

<figure>
<img src="images/alhhwarizmi.jpg" alt="A statue of al-Khwārizmī thinking"/>
<figcaption> Al-Khwarizmi
(© Yunuskhuja Tuygunkhujaev, Wikimedia Commons, CC BY-SA 4.0)</figcaption>
</figure>

<p>You actually have learned several of these sorts of mathematical algorithms
yourself while in school.  For example, if I asked you to add 137 to 226, you
could do so (even though you probably have never added these specific numbers
before).  That's because you learned an algorithm as a child for adding numbers
like this.  That algorithm will allow you to add any two numbers by following
its step-by-step process.</p>

<p>One really important aspect of algorithms is that you can use them to solve
problems <em>whether or not you understand how the algorithm is working</em>.
This was important in the past because it meant you only had to be really
clever once, to come up with the algorithm in the first place.  After that you,
and anyone else, could just follow the algorithm's instructions to solve new
problems with it.  As a child, you didn't have to understand all of the logic
behind the adding algorithm to use it.  Nowadays this is even more important
because most algorithms are not followed by people, but by computers.
Computers don't understand anything, but they can be made to follow the steps
of an algorithm automatically.</p>

<h3>1.2 Algorithm Design</h3>
<hr />

<p>One major part of computer science is <em>designing</em> algorithms.  As we
will see throughout this book, there are many problems that can be solved with
a good algorithm.  Designing algorithms can be a fun and challenging activity.
It involves both sides of your brain in that it takes both logic and creativity
to do.</p>

<p>Let's look at an example of an algorithm to solve the "guess the number"
game.  In the simplest version of this game, one player thinks of a number
between 1 and some upper limit.  Then the other player guesses which number
they picked until they get it.</p>

<p>Let's say that Mark and Sofia are playing this game with an upper limit of
10.  The game might go like this:</p>

<pre><code class="ini">
Mark: I'm thinking of a number between 1 and 10.
Sofia: Is it 7?
Mark: No.
Sofia: Is it 3?
Mark: No.
Sofia: Is it 2?
Mark: No.
Sofia: Is it 8?
Mark: Yes.
</code></pre>

<p>In this case, Sofia solved the problem by eventually guessing Mark's number.
Now we'll consider writing an algorithm which will always solve the game, no
matter what number Mark picks.</p>

<p>Sofia tried numbers in a sort of random order until she hit on the right
one.  Most people would do this, but it isn't really necessary.  Instead we
could just start at 1, and then guess 2, and then 3 and so on until we get the
right number.  This particular algorithm won't solve the problem the same way a
person might, but that's OK.  An algorithm for doing this could be written
as:</p>


<strong>Algorithm 1</strong>
<pre><code class="ini">
1. Set G to 1.
2. Ask if their number is G.
3. If it was, then we are done!
4. If it was not, then add 1 to G.
5. Go back to step 2.
</code></pre>


<p>This algorithm<a class="anchor" id="back2">&nbsp;</a><a href="#note2"
aria-describedby="footnote-label"></a> works by keeping track of
which number we are going to be guessing next, which we call "G".  This is a
<strong>variable</strong>, which is a very important concept in programming.  A
variable is a name that we give to a value which may change as the algorithm is
run.  Here, G starts off at 1, but it will change later.</p>

<p>In step 2, we ask the other player if their number is G or not.  Of course
we don't ask them if they literally picked "G".  Only numbers are allowed in
this game, not letters!  Instead the algorithm means that we should instead ask
if their number is the <em>current value</em> of G, whatever that happens to
be.  The first time it will be 1, but as we have said, G will change.</p>

<p>In step 3 and 4, we are going to do different things based on whether or not
the guess was correct.  If it was, then the algorithm is done.  If not, we add
1 to the variable G.  When the algorithm first reaches this step, it will
change G from 1 to 2.</p>

<p>Step 5 is crucial here.  It tells us to go back to step 2.  This creates a
<strong>loop</strong>, which is when an algorithm does the
same step or steps multiple times.  Even though only step 2 makes a guess, the
algorithm can keep on guessing numbers because of the loop.</p>

<p>We'll now trace through the algorithm to see how it works.  Let's suppose
that we pick 3 as our number and see if the algorithm can guess it.  The
algorithm will go step by step as follows:</p>

<ul>
<li>It will start with step 1 and set G to 1.</li>
<li>Next it will go onto step 2 and ask us if the number is G (currently 1).</li>
<li>We will respond that no, it is not.</li>
<li>The algorithm will then skip over step 3 (we aren't done yet) and go to step 4.</li>
<li>In step 4, the algorithm will add 1 to G.  Now G is going to be 2.</li>
<li>Step 5 will then move the algorithm back to step 2.</li>
<li>Back at step 2, the algorithm will ask us if the number is G (which is now equal to 2).</li>
<li>We will tell it no.</li>
<li>The algorithm will again skip over step 3 and go to step 4.</li>
<li>In step 4, the algorithm will again add 1 to G.  This changes it from 2 to 3.</li>
<li>Step 5 sends the algorithm back to step 2 again.</li>
<li>The algorithm will again ask us if the number is G (which is now 3).</li>
<li>This time, we tell it yes, since our number was 3.</li>
<li>The algorithm then sees this in step 3 and stops.</li>
</ul>


<p>One important part of working with algorithms is <em>testing</em> them.
This involves stepping through the algorithm line by line like this to see how
it's working.  Hopefully you're convinced that the algorithm will try every
number until it gets the right one.</p>

<p>Next we will look at a more interesting variation of this game.  In this
variation, instead of just answering "no" for an incorrect guess, the player
will either say that the guess was too low, or too high.  Again, consider an
example with two players.  This time, the limit will be 100:</p>

<pre><code class="ini">
Mark: I'm thinking of a number between 1 and 100.
Sofia: Is it 50?
Mark: Too high.
Sofia: Is it 25?
Mark: Too low.
Sofia: Is it 37?
Mark: Too low.
Sofia: Is it 44?
Mark: Too high.
Sofia: Is it 40?
Mark: Yes.
</code></pre>

<p>This time, Sofia did not just guess numbers randomly until she hit on the
right one.  By having the extra information, she's able to guess more
intelligently.  Her first guess of 50 was the best she could have done to start
with.  The reason is because that way, no matter what Mark answered, she had
half the potential numbers eliminated.  When Mark said 50 was too high, Sofia
knew the number must have been between 1 and 49.  Had Mark instead answered
that 50 was too low, then Sofia would know the number had to be between 51 and
100.  Either way, half the possibilities were cut out.</p>

<p>Sofia used this trick again with her second guess.  When she knew the number
was between 1 and 49, she guessed right in the middle, which gave her 25.  To
get this "middle value", we can just add the numbers and divide by 2.  She kept
on doing this until she hit on the right number.  This algorithm can be given
like this:</p>

<strong>Algorithm 2</strong>
<pre><code class="ini">
1. Set min to 1.
2. Set max to 100.
3. Set G to (max + min) ÷ 2 (rounding down if needed).
4. Ask if their number is G.
5. If it is, then we are done!
6. If the guess was too high, set max to (G - 1).
7. If the guess was too low, set min to (G + 1).
8. Go back to step 3.
</code></pre>

<p>This algorithm is just bit more complicated than the last one.  Now we have
three variables involved.  "min" is used to keep track of the smallest number
the other player could be thinking of.  Likewise "max" keeps track of the
biggest number it could be.  For example, if we have narrowed it down so we
know the number is between 20 and 40, then min would be 20 and max would be 40.
These variables will change as we narrow down the possibilities.  "G" is again
used for the number we are going to guess.</p>

<p>The algorithm starts by setting min and max to reflect the fact that the
number could be anywhere between 1 and 100 to start with.  Then step 3 figures
out which number to guess.  The first time we do this, we will get 100 plus 1,
divided by 2, which gives 50.1.  The note about rounding down if needed is to
make sure we always guess a whole number, in this case 50.</p>

<p>After each guess, there are  3 possibilities.  If we got the guess right,
then we are done, just like before.  If we guessed too high, then that means
that we need to change our max variable.  We set it to whatever our last guess
was, minus 1.  To see why, consider the starting case where min is 1, max is
100, and G is 50.  If the guess of 50 was too high, then the number must be
between 1 and 49.  So we 49 as the new max value.  Similar logic holds for when
the guess was too low.</p>

<p>Finally we go back to step 3 to pick a new guess again.  This algorithm will
eventually guess the correct number for playing this version of the game.  I
would encourage you to try it yourself once or twice to convince yourself that
it works.</p>


<h3>1.3 Algorithm Analysis</h3>
<hr />

<p>Another major part of computer science is <em>analyzing</em> algorithms.
Oftentimes a problem will have more than one algorithm to solve it.  We then
will want to compare the algorithms and see which takes less steps.  We now
have two algorithms we can analyze.  Notice that we could use both algorithms
for the second variant of the game (where the player answers too low or too
high instead of just no).  The first algorithm would just guess starting at 1
all the way up until it got the number.  But which algorithm is better?  And by
how much?  These are the questions of algorithm analysis.</p>

<p>When analyzing algorithms, we want to know how many steps they take in
different cases.  We often consider the average case or the worst case.  The
average case is helpful because it gives you an idea of how long the algorithm
will usually take.  The worst case is helpful because it gives you a guarantee
on how long it will take.  If the algorithm performs well enough in the
worst case, you know it will work well for you.  The best case is usually not
very interesting.  Here we will focus on the worst case.</p>

<p>Let's consider algorithm 1 first (the one that just starts at 1, then 2,
then 3, etc.)  If we are playing the game between 1 and 100, what's the most
number of guesses that the algorithm could take?  Clearly the worst case is
that the other player chose 100 as his or her number, because that would be the
algorithm's last guess.  In this case, we would have to make 100 guesses before
we get it right.  If we were playing between 1 and 1,000 then we would need
1,000 guesses in the worst case.</p>

<p>Analyzing algorithm 2 is more complicated.  The worst case with this
algorithm is that we never "get lucky" by guessing the number correctly until
we are 100% sure of what it is.  We are only 100% sure when we have narrowed
down the range to 1 number, and min and max are the same value.  Below is an
example of when this could happen:</p>

<pre><code class="ini">
&gt; min = 1, max = 100.  Is your number 50?
Too high.
&gt; min = 1, max = 49.  Is your number 25?
Too low.
&gt; min = 26, max = 49.  Is your number 37?
Too low.
&gt; min = 38, max = 49.  Is your number 43?
Too high.
&gt; min = 38, max = 42.  Is your number 40?
Too high.
&gt; min = 38, max = 39.  Is your number 38?
Too low.
&gt; min = 39, max = 39.  Is your number 39?
Yes.
</code></pre>

<p>As you can see, the algorithm was not lucky enough to get the number right
until the very end when it had eliminated all the other possibilities.  In this
worst case it took 7 guesses to get the number.  There are other worst case
numbers, but they all take 7 guesses to reach.</p>

<p>The number 7 here comes from the number of times we can cut the
possibilities in half before we run out.  There were 100 possibilities to begin
with, and with each guess we eliminate half of them.  If we repeatedly divide
100 by 2 (rounding down because we eliminate the guessed number itself as
well), then we get this sequence of numbers:</p>

<pre><code class="ini">
100
50
25
12
6
3
1
</code></pre>

<p>It took 7 guesses for this reason<a class="anchor" id="back3">&nbsp;</a><a href="#note3"
aria-describedby="footnote-label"></a>.  Below is a table showing
the number of guesses needed in the worst case for both algorithms, based on
the highest number the other player could pick:</p>

<div class="scrolly">
<table>
<tr><th>Highest Number</th> <th>Algorithm 1 Guesses</th> <th>Algorithm 2 Guesses</th></tr>
<tr><td>10</td><td>10</td><td>4</td></tr>
<tr><td>100</td><td>100</td><td>7</td></tr>
<tr><td>1,000</td><td>1,000</td><td>10</td></tr>
<tr><td>1,000,000</td><td>1,000,000</td><td>20</td></tr>
<tr><td>1,000,000,000</td><td>1,000,000,000</td><td>30</td></tr>
</table>
</div>

<p>It is sort of amazing that we can ask algorithm 2 to guess a number between
1 and 1 billion, and it will need only 30 guesses at most to get it!  Algorithm
2 is not just a bit better for this problem, it's way better!  It's actually
quite common in computer science for there to be huge differences in speed
between different approaches like this.  Oftentimes the obvious solution is not
very efficient, but a more clever one is.</p>

<p>This book will spend more time on algorithm design than analysis, but it is
an important part of computer science and we will touch on it from time to
time.</p>


<h3>1.4 What is a Computer?</h3>
<hr />

<p>Computer science is primarily the study of algorithms, but computers do play
a role as well.  In this section we will talk about what computers are, what
programs are, and how computers can run programs.</p>

<p>It might seem a bit silly to define what a computer is, since you likely use
a computer every day and clearly know what one is.  However, we will define a
<strong>computer</strong> as any device that is capable of
running algorithms automatically.  The earliest computers were created to run a
handful of particular algorithms, and couldn't do anything else.</p>

<p>One of the earliest such devices was Pascal's calculator, also called a
Pascaline.  This device, created by the French mathematician Blaise Pascal in
the mid-1600s, was capable of adding and subtracting numbers.  It could also do
multiplication and division by means of repeated additions or subtractions.  A
number of other mathematicians and inventors made similar mechanical devices,
including Gottfried Wilhelm Leibniz.</p>

<figure>
<img src="images/pascaline.jpg"
alt="Pascal's calculator is a bronze device with six numerical readouts and six dials." />
<figcaption> Pascal's calculator (1649)
(© Rama, Wikimedia Commons CC BY-SA 3.0 FR)</figcaption>
</figure>

<p>Another pioneer in early computers was the British mathematician and
engineer Charles Babbage.  He designed the difference engine, which could
compute polynomial values.  He completed a prototype of the difference engine
in 1822.  The difference engine was mechanical and was operated with a hand
crank.  He began working on a larger version which could operate on bigger
numbers, with more precision.</p>

<p>Before the full difference engine was completed, however, Babbage began
working on a more ambitious project, the analytical engine.  Babbage's design
of the analytical engine was a huge breakthrough in computer science, because
it was the first design for a <em>programmable</em> computer.  Pascal's
calculator, the difference engine, and every other computing device up until
that point was designed to do one fixed task.  If you wanted it to solve a
different problem, you had to build an entirely new machine.</p>

<p>The analytical engine, on the other hand, was designed so that it could
execute any algorithm at all.  It did this by taking the instructions that it
should execute as input, along with data values to be used in the computation.
These sets of instructions are the worlds first computer programs.  The
analytical engine's programs themselves were created by punching holes in
cards.  The machine would then read the cards in, and the patterns of holes
would affect its behavior.</p>

<figure>
<img src="images/analytical.png"
alt="On the left is a prototype for the analytical engine, on the right are some
of the punched cards designed to give the machine its program" />
<figcaption>Left: a model of part of the analytical engine
(© Bruno Barral, Wikimedia Commons, CC BY-SA 2.5).
Right: punched cards for use with the machine
(© Karoly Lorentey, Wikimedia Commons, CC BY 2.0)</figcaption>
</figure>

<p>Babbage worked with Ada Lovelace, who was incidentally the daughter of the
poet Lord Byron.  She worked on translating algorithms so that they could be
executed by the analytical engine.  The first of these was a program to compute
the Bernoulli numbers.  This was the first published computer program.  A
<strong>program</strong> is an algorithm that is written
specifically for a computer to execute.  Unlike Babbage and others, Ada
believed the analytical engine to be capable of going beyond number crunching,
including speculating that the engine could be used to create music.</p>

<figure>
<img src="images/babbageada.jpg"
alt="On the left a photograph of Charles Babbage, on the right
a painting of Ada Lovelace." />
<figcaption>Left: Charles Babbage. Right: Ada Lovelace.</figcaption>
</figure>

<p>Unfortunately, the analytical engine was never completed, primarily due to a
lack of funding.  A general-purpose computer was not actually completed until
more than 100 years after the design of the analytical engine.  In the 1940s,
there were several working computers developed. These include the Z4 by the
German Konrad Zuse, the Colossus developed in Great Britain to break coded
messages, and the ENIAC developed at the University of Pennsylvania to
calculate ballistics trajectories.

<figure>
<img src="images/z4.jpg"
alt="The Z4 computer as seen in a museum, it consists of banks of
vacuum tubes, along with a control console" />
<figcaption>The Z4 (1944)
(© Clemens Pfeiffer, CC BY 2.5)</figcaption>
</figure>

<figure>
<img src="images/colossus.jpg"
alt="An old photograph of the Collossus depicting banks of
electronics, a tape reel, and two women working with the machine" />
<figcaption>The Colossus (1944)</figcaption>
</figure>


<figure>
<img src="images/eniac.jpg"
alt="An old photograph of the ENIAC showing rows electronics and
cords, along with a man and a woman working with the machine" />
<figcaption>The ENIAC (1946)</figcaption>
</figure>

<p>Unlike the Analytical Engine, which was completely mechanical, these
computers used electronic circuitry.  After these machines were successfully
built and used, there was no turning back, and computers have been constantly
built and improved upon until the present day.</p>

<p>Despite being as large as rooms, these older computer are laughably limited
compared to even the most basic of today's computers.  The Z4 ran at 40 Hz and
had 512 bytes of memory.  The first iPhone, released in 2007, could run at 620
MHz (15 million times faster), and came with at least 4 GB of memory (7 million
times more).</p>

<p>While these older computers were woefully slow and had tiny memories, they
functioned in essentially the same way as every computer designed since.  They
all consist of a processor, memory and some input/output devices.  Below is a
simplified diagram of a computer system.</p>

<figure>
<img src="images/computer.png"
alt="A CPU and memory are grouped together forming the core of a computer
system.  They exchange information back and forth.  Input devices feed into
the computer, which in turn writes to output devices." />
<figcaption>A functional view of a computer</figcaption>
</figure>

<p>The <strong>CPU</strong> (which stands for central processing unit), is
responsible for carrying out the instructions of a program.  Each instruction
is very simple and precise.  For example, the following are examples of typical
CPU instructions:</p>


<ul>
<li>Take the numbers in two memory cells add them together.  Put the
answer in another memory cell.</li>

<li>Check if one memory cell is equal to another.  If so, jump to a different
part of the program.</li>

<li>Check if a certain key on the keyboard is pressed.  If so, set a memory
cell to 1.  Otherwise, set it to 0.</li>
</ul>

<p>Although the individual instructions a CPU carries out are very basic,
enough of them put together are able to accomplish great things.</p>

<p>The <strong>memory</strong> of a computer is responsible for storing
numbers.  Everything represented in a computer is done with numbers.  For
instance, when you send an email, the text that you write must be stored inside
the computer as well.  But, like everything else, this is done with numbers.
The letters and punctuation symbols have specific numbers assigned to them.
For instance when you type an 'A', the computer stores a 65.  When you type a
period, the computer stores a 46.  When you type a space, the computer stores a
32.</p>

<p>Of course, the way that computers store numbers is in <em>binary</em>, which
means they only use 1's and 0's.  We will not talk about how to convert
back and forth between binary and decimal numbers.  Just know that any number
can be stored in either binary or decimal, and they mean the same thing.</p>

<p>Even images and sounds are stored inside a computer as numbers.  We will
talk about how that is done in later chapters.</p>

<p><strong>Input devices</strong> include touch screens, mice, keyboards, game
controllers and so on.  These are connected to a computer system so that the
user can influence the programs running on the computer.</p>

<p>Likewise, <strong>output devices</strong> are connected to a computer so that
the user can see what the computer is doing and see the result of the program
which is running.  These include monitors, speakers, printers, and vibration
units (which can vibrate to provide the user feedback).</p>

<h3>1.5 Programming Languages</h3>
<hr />

<p>So the computer executes simple instructions, reads and writes its memory,
gets input from the user, and gives the user output.  But where do the
instructions come from?  They are actually stored inside the computer's memory
as numbers too!</p>

<p>As an example of a computer instruction, we can look at one of the steps
of Algorithm 1 to solve the simple guess the number game:</p>

<pre><code class="ini">
add 1 to g.
</code></pre>

<p>Let's look at what this step would look like as a real computer instruction<a class="anchor" id="back4">&nbsp;</a><a href="#note4" aria-describedby="footnote-label"></a>.
But first, we would need to decide what memory location to store <code>G</code>
in.  Let's say we put it in location 7.</p>

<p>This instruction would tell the CPU to add 1 to memory location 7:</p>

<pre><code class="ini">
          operation     destination   input   amount
1110001   0100       0  0111          0111    00000001 0000
</code></pre>

<p>This is a <em>binary</em> number.  We'll just point out some of the parts
of this.  The 0100 labeled "operation" tells the CPU what sort of thing
it's doing.  0100 is the code for addition.  So it tells the CPU to add
instead of subtract, multiply, or anything else.</p>

<p>The first 0111 labeled "destination" tells the CPU where to put the result.
0111 is binary for 7.  So it puts the answer in memory cell 7.  The second
0111, labeled "input" tells the CPU what value to read in the addition.  This
is also 7.  Lastly the 00000001 labeled "amount" tells the CPU how much to
add.  In total the instruction tells the CPU to read memory cell 7, add 1 to
it, and put the answer back in memory cell 7.</p>

<p>The other, unlabelled parts just tell the CPU what type of instruction it
is, and how to interpret the other fields.  All together the instruction is the
following binary number:</p>

<pre><code class="ini">
11100010100001110111000000010000
</code></pre>

<p>In decimal, this is equal to:</p>

<pre><code class="ini">
3800526864
</code></pre>

<p>So the way computers work is by reading in these numbers.  The numbers tell
them what they are supposed to do.  Part of the computer's memory is dedicated
to storing these instruction numbers for the programs it runs.  It reads the
instructions one by one and carries them out.  Programs stored as actual
numbers like this are <strong>machine code</strong> programs.</p>

<p>In case you are panicking right now, let me assure you that nobody actually
writes programs this way!  Giving a computer a program by writing a sequence of
numbers like this would be tedious beyond belief.</p>

<p>Instead, we have created other languages which are easier for people to use.
The first of these is <strong>assembly</strong> language, which is basically
a human-readable version of machine code.  Rather than write "0100" for add,
and "0111" for memory cell 7, we just write them out.  The instruction above
written in assembly would look like this:</p>

<pre><code class="armasm">
add r7, r7, #1
</code></pre>

<p>The computer can't run this instruction directly, it must be translated into
machine code.  That is done by a program called an <strong>assembler</strong>:</p>

<figure>
<img src="images/assembly.png"
alt="An assembler converts assembly code into machine language." />
<figcaption>An assembler converts assembly code into machine language.</figcaption>
</figure>

<p>The assembler converts each line of assembly code into the corresponding
machine code instruction.  Then, the machine code program can be run on the
computer system directly.</p>

<p>We aren't dealing with numbers directly with assembly code, but it is still
too tedious for most people.  In particular, we still have to keep track of
where in memory our variables are stored.  Knowing that memory cell 7 is storing
our guess variable, and knowing where the other variables are becomes too hard
as we begin to write larger programs.</p>

<p>Instead, we have developed <strong>high-level</strong> programming languages.
These allow us to have names for our variables, instead of needing to remember
which memory location they are in.  Here is what the instruction above might look
like in Python, the high-level language used in this book:</p>

<pre><code class="python">
guess = guess + 1
</code></pre>

<p>High-level language code is also much more succinct than assembly or machine
code.  One line of code in a language like Python can do the same work as many
lines of machine code.  Of course this code must also be translated into
machine code for the computer to execute.  That is done with a program called
an <strong>interpreter</strong>.</p>

<p>An interpreter takes code in a language like Python, and executes in line
by line.  For each line it sees, it gives one or more lines of machine code
to the computer:</p>

<figure>
<img src="images/interpreter.png"
alt="An interpreter translates high-level code into machine code." />
<figcaption>An interpreter translates high-level code into machine code.</figcaption>
</figure>

<p>Just like someone who interprets one spoken language into another, an
interpreter program translates on the fly.  As the high-level program is being
run, its code is being translated for the computer to execute.</p>



<h3>1.6 What do you do with Computer Science?</h3>
<hr />

<p>We have seen that computer science is primarily about algorithms, but this
section will address how algorithms are used in a variety of areas to solve
real problems in the world.</p>

<p>Computer science is an interesting field because it frequently works together
with other fields.  For example:</p>

<ul>
<li>Computer scientists work with natural scientists in fields like physics,
chemistry and biology to develop computer models of natural phenomenon.  It is
often impractical to carry out experiments in real life, so computer models can
be used.  For instance, there are programs which model the collision of two
galaxies, the spread of a disease through a population, or the path of a river
in the face of flooding.  These models allow scientists to test hypotheses and
compare potential solutions to problems more easily than they otherwise
could.</li>

<li>Social scientists work with computer scientists as well.  For example,
economists work with programmers to create programs which model the way markets
work.  Computer scientists also work with historians and anthropologists to
create virtual exhibits for historical artifacts.</li>

<li>Computer programs are also used in every area of industry.  Programs
determine the price of goods, they schedule flights, they manage factories and
farms, and keep track of information in schools and hospitals.  They are behind
all of the web sites and apps that you use, and provide entertainment in the
form of video games and special effects used in movies.</li> </ul>

<p>No matter what area of work you are interested in, you can be sure that
computer scientists work in that field.  All of this makes computer science an
interesting and rewarding field of study.  Because so many different fields
rely on computer programs, a computer scientist can work in a variety of
different areas over the course of their career.</p>

<p>Some computer scientists work in "pure" computer science.  These include
people who work on operating systems or the interpreters that make languages like
Python work.  But the vast majority work with people in some other area.</p>

<p>Computer science also makes a great second major or minor, because it can
provide benefits to a wide variety of fields.  We will look at some examples of
this over the course of this book.</p>

<div class="blackbox">
<div class="blackbox-title">
<strong>Chapter Summary</strong>
</div>
<div class="blackbox-contents">
<ul>
<li>Computer science is the study of algorithms.  An algorithm is a set of
directions for solving a problem.  Algorithms must be precise enough that
someone can use it to solve problems without needing to understand
how it is working.</li>

<li>A computer is a device which can carry out the steps of an algorithm
automatically.  The oldest computers could only solve problems they were
designed for.  Nowadays computers can run different algorithms at different
times.</li>

<li>For a computer to execute an algorithm, it must be programmed into a language
that the computer can understand.  Computers have a "native" machine language
which is difficult for people to use.  Most programs are written in an easier
high-level language which is translated for the computer by an
interpreter.</li>

<li>Computer scientists work to write programs that solve a variety of
problems for lots of different fields.</li>
</ul>
</div>
</div>



<footer>
<h2 class="visually-hidden" id="footnote-label">Footnotes</h2>
<ol>
<li id="note1">Before the advent of computers, the study of
algorithms was not called "computer science". It was just part of mathematics.
After computers were invented, it split off into its own field.
<a href="#back1" aria-label="Back to content">↩</a></li>

<li id="note2">This algorithm is written in "pseudocode" which is
not real computer code, but is similar to computer code. For most of this book
we will use real code, but for these first examples, we just want to talk about
the concepts in general.
<a href="#back2" aria-label="Back to content">↩</a></li>

<li id="note3">For the mathematically inclined, the worst case number of guesses has the
following relationship with the number of possibilities we start with: $guesses
= \lceil log_2(possibilities) \rceil$
<a href="#back3" aria-label="Back to content">↩</a></li>

<li id="note4">The instruction in this example is for ARM-based computer systems.
These include almost all phones, tablets and other small computers.  Most laptops
and desktops use a different format, but the ideas are the same.
<a href="#back4" aria-label="Back to content">↩</a></li>

</ol>
</footer>



